var b=Object.create;var g=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var C=Object.getOwnPropertyNames;var _=Object.getPrototypeOf,H=Object.prototype.hasOwnProperty;var k=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),D=(e,t)=>{for(var r in t)g(e,r,{get:t[r],enumerable:!0})},p=(e,t,r,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of C(t))!H.call(e,n)&&n!==r&&g(e,n,{get:()=>t[n],enumerable:!(a=E(t,n))||a.enumerable});return e};var U=(e,t,r)=>(r=e!=null?b(_(e)):{},p(t||!e||!e.__esModule?g(r,"default",{value:e,enumerable:!0}):r,e)),j=e=>p(g({},"__esModule",{value:!0}),e);var w=k((v,u)=>{var l=class{static parse(t){return new Uint8Array(Array.prototype.map.call(atob(t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"")),r=>r.charCodeAt(0)))}static stringify(t){return btoa(String.fromCharCode.apply(0,t)).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}},y=class{constructor(){if(typeof crypto>"u"||!crypto.subtle)throw new Error("Crypto not supported!");this.algorithms={ES256:{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}},ES384:{name:"ECDSA",namedCurve:"P-384",hash:{name:"SHA-384"}},ES512:{name:"ECDSA",namedCurve:"P-512",hash:{name:"SHA-512"}},HS256:{name:"HMAC",hash:{name:"SHA-256"}},HS384:{name:"HMAC",hash:{name:"SHA-384"}},HS512:{name:"HMAC",hash:{name:"SHA-512"}},RS256:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},RS384:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}},RS512:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}}}}_utf8ToUint8Array(t){return l.parse(btoa(unescape(encodeURIComponent(t))))}_str2ab(t){let r=new ArrayBuffer(t.length),a=new Uint8Array(r);for(let n=0,o=t.length;n<o;n++)a[n]=t.charCodeAt(n);return r}_decodePayload(t){switch(t.length%4){case 0:break;case 2:t+="==";break;case 3:t+="=";break;default:throw new Error("Illegal base64url string!")}try{return JSON.parse(decodeURIComponent(escape(atob(t))))}catch{return null}}async sign(t,r,a={algorithm:"HS256"}){if(typeof a=="string"&&(a={algorithm:a}),t===null||typeof t!="object")throw new Error("payload must be an object");if(typeof r!="string")throw new Error("secret must be a string");if(typeof a.algorithm!="string")throw new Error("options.algorithm must be a string");let n=this.algorithms[a.algorithm];if(!n)throw new Error("algorithm not found");t.iat=Math.floor(Date.now()/1e3);let o=JSON.stringify(t),i=`${l.stringify(this._utf8ToUint8Array(JSON.stringify({alg:a.algorithm,kid:a.keyid})))}.${l.stringify(this._utf8ToUint8Array(o))}`,h="raw",s;r.startsWith("-----BEGIN")?(h="pkcs8",s=this._str2ab(atob(r.replace(/-----BEGIN.*?-----/g,"").replace(/-----END.*?-----/g,"").replace(/\s/g,"")))):s=this._utf8ToUint8Array(r);let c=await crypto.subtle.importKey(h,s,n,!1,["sign"]),m=await crypto.subtle.sign(n,c,this._utf8ToUint8Array(i));return`${i}.${l.stringify(new Uint8Array(m))}`}async verify(t,r,a={algorithm:"HS256"}){if(typeof a=="string"&&(a={algorithm:a}),typeof t!="string")throw new Error("token must be a string");if(typeof r!="string")throw new Error("secret must be a string");if(typeof a.algorithm!="string")throw new Error("options.algorithm must be a string");let n=t.split(".");if(n.length!==3)throw new Error("token must consist of 3 parts");let o=this.algorithms[a.algorithm];if(!o)throw new Error("algorithm not found");let i=this.decode(t);if(i.nbf&&i.nbf>Math.floor(Date.now()/1e3)||i.exp&&i.exp<=Math.floor(Date.now()/1e3))return!1;let h="raw",s;r.startsWith("-----BEGIN")?(h="pkcs8",s=this._str2ab(atob(r.replace(/-----BEGIN.*?-----/g,"").replace(/-----END.*?-----/g,"").replace(/\s/g,"")))):s=this._utf8ToUint8Array(r);let c=await crypto.subtle.importKey(h,s,o,!1,["sign"]),m=await crypto.subtle.sign(o,c,this._utf8ToUint8Array(n.slice(0,2).join(".")));return l.stringify(new Uint8Array(m))===n[2]}decode(t){return this._decodePayload(t.split(".")[1].replace(/-/g,"+").replace(/_/g,"/"))}};u.exports=new y});var N={};D(N,{jwtDecode:()=>d,jwtSign:()=>S,jwtVerify:()=>A});module.exports=j(N);var f=U(w()),S=f.default.sign,A=f.default.verify,d=f.default.decode;
